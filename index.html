<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal Physics Puzzle Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            width: 100vw;
            height: 100vh;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            text-align: center;
            z-index: 100;
        }
        #instructions h2 {
            margin-top: 0;
            color: #00ffff;
        }
        #instructions .controls {
            text-align: left;
            margin: 20px 0;
        }
        #instructions .note {
            font-size: 14px;
            color: #aaa;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="instructions">
        <h2>Portal Physics Puzzle</h2>
        <p><strong>Click to start</strong></p>
        <div class="controls">
            <p><strong>Controls:</strong></p>
            <p>• WASD - Move</p>
            <p>• Mouse - Look around (X-Axis Inverted)</p>
            <p>• Space - Jump</p>
            <p>• Left Click - Blue Portal (White Walls Only)</p>
            <p>• Right Click - Orange Portal (White Walls Only)</p>
            <p>• E - Pick up/Drop cube</p>
        </div>
        <p class="note">
            Portals only work on WHITE surfaces. Place the golden cube on the red button to open the green door!
        </p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        const instructionsEl = document.getElementById('instructions');

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 0, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // Game state
        const state = {
            velocity: new THREE.Vector3(),
            onGround: false,
            holdingCube: false,
            heldCube: null,
            portalGun: { blue: null, orange: null }
        };

        const keys = {};
        const mouse = { x: 0, y: 0, locked: false };

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // Materials
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x444444 }); // Dark gray (No portals)
        const wallMatNonPortal = new THREE.MeshStandardMaterial({ color: 0x444444 }); // Dark gray (No portals)
        const wallMatPortal = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White (Portals allowed)

        // Floor
        const floorGeo = new THREE.PlaneGeometry(50, 50);
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        floor.userData = { type: 'floor', portalable: false };
        scene.add(floor);

        // Walls
        function createWall(w, h, x, y, z, rotY = 0, portalable = false) {
            const geo = new THREE.BoxGeometry(w, h, 0.5);
            const mat = portalable ? wallMatPortal : wallMatNonPortal;
            const wall = new THREE.Mesh(geo, mat);
            wall.position.set(x, y, z);
            wall.rotation.y = rotY;
            wall.receiveShadow = true;
            wall.castShadow = true;
            wall.userData = { type: 'wall', portalable: portalable };
            scene.add(wall);
            return wall;
        }

        // Environment boundaries
        createWall(50, 10, 0, 5, -25, 0, true);  // North (White)
        createWall(50, 10, 0, 5, 25, 0, false);  // South (Gray)
        createWall(50, 10, -25, 5, 0, Math.PI / 2, true); // West (White)
        createWall(50, 10, 25, 5, 0, Math.PI / 2, false); // East (Gray)

        // Add some interior portalable walls
        createWall(10, 10, 5, 5, -5, 0, true);
        createWall(10, 10, -15, 5, 10, Math.PI / 2, true);

        // Add platforms (Non-portalable)
        const platformMat = new THREE.MeshStandardMaterial({ color: 0x606060 });
        function createPlatform(w, h, d, x, y, z) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const platform = new THREE.Mesh(geo, platformMat);
            platform.position.set(x, y, z);
            platform.receiveShadow = true;
            platform.castShadow = true;
            platform.userData = { type: 'platform', portalable: false };
            scene.add(platform);
            return platform;
        }

        createPlatform(8, 1, 8, -10, 2, -10);
        createPlatform(8, 1, 8, 10, 4, 10);
        createPlatform(6, 1, 6, 15, 6, -5);

        // Companion cube
        const cubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const cubeMat = new THREE.MeshStandardMaterial({ color: 0xd4af37 });
        const cube = new THREE.Mesh(cubeGeo, cubeMat);
        cube.position.set(5, 2, 5);
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.userData = { type: 'cube', velocity: new THREE.Vector3() };
        scene.add(cube);

        // Button
        const buttonGeo = new THREE.CylinderGeometry(1, 1, 0.2, 32);
        const buttonMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const button = new THREE.Mesh(buttonGeo, buttonMat);
        button.position.set(-15, 0.1, -15);
        button.userData = { type: 'button', pressed: false };
        scene.add(button);

        // Door
        const doorGeo = new THREE.BoxGeometry(4, 6, 0.5);
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const door = new THREE.Mesh(doorGeo, doorMat);
        door.position.set(20, 3, -24.5);
        door.userData = { type: 'door', open: false };
        scene.add(door);

        // Portal creation
        function createPortal(color) {
            const portalGeo = new THREE.RingGeometry(1.5, 1.8, 32);
            const portalMat = new THREE.MeshBasicMaterial({ 
                color: color, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const portal = new THREE.Mesh(portalGeo, portalMat);
            
            const glowGeo = new THREE.RingGeometry(0, 1.5, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            portal.add(glow);
            
            portal.userData = { type: 'portal', color: color === 0x0066ff ? 'blue' : 'orange' };
            return portal;
        }

        const raycaster = new THREE.Raycaster();
        const rayDirection = new THREE.Vector3();

        // Player setup
        camera.position.set(0, 2, 10);
        const playerHeight = 2;
        const moveSpeed = 0.15;
        const jumpForce = 0.3;
        const gravity = 0.015;

        // Event listeners
        function onKeyDown(e) {
            keys[e.code] = true;
            if (e.code === 'Space' && state.onGround) {
                state.velocity.y = jumpForce;
                state.onGround = false;
            }
            if (e.code === 'KeyE') {
                if (!state.holdingCube) {
                    camera.getWorldDirection(rayDirection);
                    raycaster.set(camera.position, rayDirection);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    for (let intersect of intersects) {
                        if (intersect.object.userData.type === 'cube' && intersect.distance < 4) {
                            state.holdingCube = true;
                            state.heldCube = intersect.object;
                            break;
                        }
                    }
                } else {
                    state.holdingCube = false;
                    state.heldCube = null;
                }
            }
        }

        function onKeyUp(e) {
            keys[e.code] = false;
        }

        function onMouseMove(e) {
            if (!mouse.locked) return;
            // Inverted X-Axis (e.movementX * -1)
            mouse.x -= e.movementX * 0.002; 
            mouse.y -= e.movementY * 0.002;
            mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
        }

        function onMouseDown(e) {
            if (!mouse.locked) return;
            
            camera.getWorldDirection(rayDirection);
            raycaster.set(camera.position, rayDirection);
            const intersects = raycaster.intersectObjects(scene.children);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                
                // Only place on portalable (white) surfaces
                if (hit.object.userData.portalable) {
                    const isLeftClick = e.button === 0;
                    const portalKey = isLeftClick ? 'blue' : 'orange';
                    const portalColor = isLeftClick ? 0x0066ff : 0xff6600;
                    
                    if (state.portalGun[portalKey]) {
                        scene.remove(state.portalGun[portalKey]);
                        state.portalGun[portalKey] = null;
                    }
                    
                    const portal = createPortal(portalColor);
                    
                    // Position: slightly offset from face
                    portal.position.copy(hit.point);
                    portal.position.add(hit.face.normal.clone().multiplyScalar(0.05));
                    
                    // Rotation: Correctly align with surface normal
                    const lookTarget = hit.point.clone().add(hit.face.normal);
                    portal.lookAt(lookTarget);
                    
                    scene.add(portal);
                    state.portalGun[portalKey] = portal;
                }
            }
        }

        function onClick() {
            if (!mouse.locked) {
                renderer.domElement.requestPointerLock();
            }
        }

        function onPointerLockChange() {
            mouse.locked = document.pointerLockElement === renderer.domElement;
            if (mouse.locked) {
                instructionsEl.classList.add('hidden');
            } else {
                instructionsEl.classList.remove('hidden');
            }
        }

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('click', onClick);
        document.addEventListener('pointerlockchange', onPointerLockChange);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            camera.rotation.order = 'YXZ';
            camera.rotation.y = mouse.x;
            camera.rotation.x = mouse.y;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

            const moveDir = new THREE.Vector3();
            if (keys['KeyW']) moveDir.add(forward);
            if (keys['KeyS']) moveDir.sub(forward);
            if (keys['KeyA']) moveDir.sub(right);
            if (keys['KeyD']) moveDir.add(right);

            if (moveDir.length() > 0) {
                moveDir.normalize().multiplyScalar(moveSpeed);
                camera.position.add(moveDir);
            }

            if (!state.onGround) {
                state.velocity.y -= gravity;
            }
            camera.position.y += state.velocity.y;

            if (camera.position.y < playerHeight) {
                camera.position.y = playerHeight;
                state.velocity.y = 0;
                state.onGround = true;
            }

            camera.position.x = Math.max(-24, Math.min(24, camera.position.x));
            camera.position.z = Math.max(-24, Math.min(24, camera.position.z));

            if (state.holdingCube && state.heldCube) {
                camera.getWorldDirection(forward);
                state.heldCube.position.copy(camera.position);
                state.heldCube.position.add(forward.multiplyScalar(3));
                state.heldCube.position.y = camera.position.y - 0.5;
            } else if (cube.userData.type === 'cube') {
                cube.userData.velocity.y -= gravity;
                cube.position.add(cube.userData.velocity);
                if (cube.position.y < 0.75) {
                    cube.position.y = 0.75;
                    cube.userData.velocity.y = 0;
                }
            }

            const distToButton = cube.position.distanceTo(button.position);
            if (distToButton < 1.5 && !button.userData.pressed) {
                button.userData.pressed = true;
                buttonMat.color.setHex(0x00ff00);
                door.userData.open = true;
                door.position.y = -3;
            }

            // Portal teleportation logic
            if (state.portalGun.blue && state.portalGun.orange) {
                const distToBlue = camera.position.distanceTo(state.portalGun.blue.position);
                const distToOrange = camera.position.distanceTo(state.portalGun.orange.position);
                
                if (distToBlue < 1.5) {
                    // Teleport to Orange
                    const outNormal = new THREE.Vector3(0, 0, 1);
                    outNormal.applyQuaternion(state.portalGun.orange.quaternion);
                    camera.position.copy(state.portalGun.orange.position).add(outNormal.multiplyScalar(2));
                } else if (distToOrange < 1.5) {
                    // Teleport to Blue
                    const outNormal = new THREE.Vector3(0, 0, 1);
                    outNormal.applyQuaternion(state.portalGun.blue.quaternion);
                    camera.position.copy(state.portalGun.blue.position).add(outNormal.multiplyScalar(2));
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
